# -*- coding: utf-8 -*-
"""Assignment #6: Built in Functions

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1__G9Pc9QhkifGkr3qQj1vozqCzZpCwof

**def describe_stats**
"""

# this is the library to use the built in functions for the descriptive statistics calculations
import statistics

def describe_stats():
    while True:

        upper_limit = int(input("Enter the upper limit: "))
        lower_limit = int(input("Enter the lower limit: "))
        step_size = int(input("Enter the step size: "))

        # to find the total range for the calculations:
        range_values = range(lower_limit, upper_limit + 1, step_size) # add one to the upper limit because its exclusive

        # preforming the calculations:
        median_value = statistics.median(range_values)
        mean_value = statistics.mean(range_values)
        range_value = abs(upper_limit - lower_limit)

        print("Median:", median_value)
        print("Mean:", mean_value)
        print("Range:", range_value)

        run_stats_again = input("run again?: ")
        if run_stats_again != 'y':
            break

"""**def cipher**"""

# numbers : 57 73 73 64 26 -108 79 -99 71 26 73 72 26 81 73 79 76 26 -109 69 64 78 65 76 -109 27

# INSTRUCTIONS: his cipher uses a combination of ascii, decimal, and octal values.
# The values would be written in decimal values, which would then need to be transformed to octal values, before being translated into ascii characters.
# Unless, that value canâ€™t be written in octal value, then it will listed as a negative decimal value. Write a program that takes a string of numbers as input and will return the
# translated message.

#1. convert to octal
#2. convert to ASCII
# IF NUMBER IS NEGATIVE THEN CONVERT TO POSITIVE ????????????

# this user defined function specificaly uses the 'decimal_values' to decipher the message.
def decipher():
    # first you have to innitialize to empty (OR ELSE IT WON"T WORK.)
    message = ''
    # these are the innitial values (in decimal)
    decimal_values = [57, 73, 73, 64, 26, -108, 79, -99, 71, 26, 73, 72, 26, 81, 73, 79, 76, 26, -109, 69, 64, 78, 65, 76, -109, 27]

    # then i will get rid of any negative values and make them positive to convert
    positive_values = []
    for val in decimal_values:  # for a vlue in the given decimal values ...
        positive_values.append(abs(val))  # use abs to convert to positive if negative and then store in filtered values using .append

    # for i in the given values .....
    for decimal in decimal_values:
        if decimal >= 0: # make sure the number is positive
            octal_str = oct(decimal)[2:] # convert decimal to octal string (ensure correct range and get rid of 'Oo' in octal value?) it didn't run correctly before
            ascii_char = chr(int(octal_str)) # convert octal string for each value to ASCII character, it should be an int i think
            message += ascii_char # add to the message
    # print the deciphered message
    return message
    print(message)
  # i dont think this is the correct message, im assuming im doing something wrong with the negative value handling, but i'm not sure.

"""**MAIN**"""

while True:
  # for user to chose the program
  program_choice = input("Enter the program you would like to run: ('s' for statistics or 'd' for decipher: )")

  # in case user enters an invalid program choice
  if program_choice != 's' and program_choice != 'd':
    print("Invalid choice. Please try again. ")
    continue

  # For descriptive statistics
  elif program_choice == 's':
    describe_stats()

  # for cipher translator
  elif program_choice == 'd':
    deciphered_message = decipher()
    print(deciphered_message)
    print("I think the message is supposed to say 'good luck on your interview'.\n")

  # in case user enters an invalid choice
  else:
    print("invalid choice. Please try again. /n")
    continue

# run program again (while loop)
  run_program_again = input("Would you like to run the program again? ('y' for yes, 'stop' to exit): ")
  if run_program_again != 'y':
    break